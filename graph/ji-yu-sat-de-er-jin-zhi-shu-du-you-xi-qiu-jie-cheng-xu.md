---
description: 数据结构课设
---

# 基于SAT的二进制数独游戏求解程序

## 介绍项目

数据结构课设，主要考察数据结构设计运用和问题转化的能力。

该项目分成两个部分：

* 基于DPLL算法实现SAT完备求解器
* 将数独游戏转化为SAT问题并使用求解器求解

功能要求：

* **输入输出** 包括程序执行参数的输入，SAT算例cnf文件的读取，执行结果的输出与文件保存等
* **公式解析与验证：** 读取cnf算例文件，解析文件，建立公式的内部表示；并实现对解析正确性的验证功能，即遍历内部结构逐行输出与显示每个子句，与输入算例对比可人工判断解析功能的正确性
* **DPLL过程**： 基于DPLL算法框架，实现SAT算例的求解
* **时间性能的测量**
* **程序优化**
* **SAT应用** 将数独游戏问题转化为SAT问题，并集成到上面的求解器进行问题求解，游戏可玩，具有一定的/简单的交互性

## 核心要点：SAT解析、DPLL算法、数独游戏转化

### SAT解析

**SAT问题**即命题逻辑公式的可满足性问题，是一个典型的NP完全问题。

**具体定义：**_**对于给定布尔变元集合以及其子句集合，若对于其子句的合取范式\(CNF范式\)，判断是否有一组对于布尔变元的赋值使得该CNF范式为真**_

有CNF范式F=（¬a∨b∨c）∧（¬a∨¬b）∧（¬b∨c），当a=0，b=0，c=1时候，这个公式F取真，则称这个公式是可满足（satisfied）的，一组解是a=0，b=0，c=1。

### DPLL算法

#### DPLL算法相关概念介绍

**文字\(literal\)和子句\(clause\)**   

对于任一布尔变元x，x与其非“¬x”称为**文字**。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为**子句**。

只含一个文字的子句称为**单子句**。不含任何文字的子句称为**空子句**。

**单子句规则**

若字句S中有一个单子句L，则L一定取真，从S中删除所有有L的子句，得到S1，若其为空集，则S可满足。

如果此时S1不是空集，那么对于S1中的每一个子句，若有¬L，则去掉这个文字，得到S2。

S满足当且仅当S2满足。

#### DPLL算法综述

1. 输入一个子句集S，使得其进入DPLL算法，若满足返回true，不满足返回为false。
2. 接下来是一个循环。从S中选择单子句L，利用上述提到的单子句规则来化简L。
3. 如果此时化简结果是S为空集，证明可满足，返回true。
4. 如果此时S不为空集但是S中有子句是空子句，证明不可满足（无论取怎样的布尔值组都不可满足）。
5. 若是其他情况，继续循环，寻找S中的单子句，重复上面三步。
6.  直到S中没有单子句，此时从S中选择一个v使其成为单子句，加入S递归调用DPLL，若返回值不为true，则v变为¬v，递归调用DPLL。

![DPLL&#x7B97;&#x6CD5;&#x641C;&#x7D22;&#x6811;](../.gitbook/assets/image%20%288%29.png)

### 二进制数独游戏转化

**二进制数独约束：**

* 在每一行、每一列中不允许有连续的3个1或3个0出现； \( x1∨x2∨x3\)∧\( ¬x1∨¬x2∨¬x3\) 在2m阶的数独中，共有2m\*2m个变量，共产生8m\*（2m-2）个字句
* 在每一行、每一列中1与0的个数相同；  
* 不存在重复的行与重复的列。

**数独规约**

第i行j列的方格转化为布尔变量表示为i \* 10 +  j。

## 问题与思考

* **DPLL算法时间复杂度，空间复杂度** 
* **更好的解决算法** SAT分为完备算法和局部搜索算法两种，本课设采用的是完备算法。完备算法一定可以找到解决方案，但是会遍历绝大部部分路径，消耗巨大。 关于局部搜索算法，联系上一个项目，可以使用相同的算法解决，即使用TS、HEA 或者 HEAD算法，搜索满足SAT的填充路径。和k-coloring问题不同在于前者判断当前填充是否满足三条约束，后者仅需判断同一颜色的节点是否相邻。
* **遇到的问题和解决方案** 

\*\*\*\*





